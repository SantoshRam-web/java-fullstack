ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class  Test 
{
	public static void main(String[] args) 
	{
		MyThread t = new MyThread();
		t.start();
		Thread.currentThread().yield();
		for(int i=1;i<=5;i++)
		{
			System.out.println("parent-Thread");
		}
	}
}

2) join()
=========
If a thread wants to wait untill the completion of some other thread then we need to use join() method.

A join() method throws one checked exception i.e InterruptedException so we must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public final void join()throws InterruptedException 
	public final void join(long ms)throws InterruptedException
	public final void join(long ms,int ns)throws InterruptedException

Diagram: class49.1

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class  Test 
{
	public static void main(String[] args)throws InterruptedException
	{
		MyThread t = new MyThread();
		t.start();
		t.join();
		for(int i=1;i<=5;i++)
		{
			System.out.println("parent-Thread");
		}
	}
}

3) sleep() 
==========
If a thread don't want to perform any operations on perticular amount of time then we need to use sleep() method.

A sleep() method throws one checked exception i.e InterruptedException so we must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public static native void sleep()throws InterruptedException 
	public static native void sleep(long ms)throws InterruptedException
	public static native void sleep(long ms,int ns)throws InterruptedException

Diagram: class49.2

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class  Test 
{
	public static void main(String[] args)
	{
		MyThread t = new MyThread();
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("parent-Thread");
		}
	}
}

Problem without synchronization 
===============================
If there is no synchronization then we will face following problems.

1) Data inconsistency 

2) Thread interference 

ex:
---
class Table 
{
	void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}

Synchronization 
================
A synchronized keyword is applicable for methods and blocks.

a synchronization allows only one thread to execute at a time. Hence we can achieve thread safety.

The main advantage of synchronization is we can achieve data consistency.

The main disadvantage of synchronization is waiting time of a thread will increase which effects on the performance.

Synchronization deals with lock mechanism.

Whenever a thread wants to access the object first it has to acquire the lock of it and release it when thread completes it's task.

In synchronization threads will get the lock automatically.

If there is a specific requirement then only we need to use synchronization.

If a thread is executing synchronized method then other threads are not allowed to execute another synchronized method. But they can execute non-synchronize method concurently.

ex:
---
class Table 
{
	synchronized void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}


synchronized block 
==================
If we want to perform synchronization on specific resource of a program then we need to use synchronized block.

If we have 100 lines but we want to perform synchronization only for 10 lines then we need to use synchronized block.

If we keep all the logics inside synchronized block then synchronized method also acts like a synchronized method.

ex:
---
class Table 
{
	void printTable(int n)
	{
		synchronized(this)
		{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
		}//sync block 
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}

static synchronization 
=====================
If we declare any static method as synchronized is called static synchronization.

In static synchronization the lock will be on class but not on object.

ex:
---
class Table 
{
	synchronized static void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	public void run()
	{
		Table.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	public void run()
	{
		Table.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread1 t1=new MyThread1();
		MyThread2 t2=new MyThread2();
		t1.start();
		t2.start();
	}
}


Inter thread communication 
==========================
Inter-thread communication is possible by using wait(), notify() and notifyAll() method.

A thread which is waiting for notification has to call wait() method.

A thread which is giving notification has to call notify() or notifyAll() method.

Wait(), notify() and notifyAll() these are the methods of Object class.

To call wait(), notify() and notifyAll() method we must have synchronized area.

If we call wait() method then our thread will release lock immediately and goes to waiting state.

If we call notify() and notifyAll() method our thread will release the lock but not immeditely.

Except wait(), notify() and notifyAll() method there is no way to release the lock.

ex:
---
class MyThread extends Thread 
{
	int total = 0;
	
	public void run()
	{
		synchronized(this)
		{
			System.out.println("Child started calulation");
			for(int i=1;i<=10;i++)
			{
				total+=i;	
			}
			System.out.println("Child Giving Notification");
			this.notify();
		}
	}
}
class Test 
{
	public static void main(String[] args)throws InterruptedException 
	{
		MyThread t = new MyThread();
		t.start();
		synchronized(t)
		{
			System.out.println("Main Method waiting for notification");
			t.wait();
			System.out.println("Main Method Got notification");
			System.out.println(t.total);
		}
	}
}


DeadLock 
=========
Deadlock will occur in a situation when a thread is waiting for object lock which is acquired by another thread and that thread is waiting for object lock which is acquired by first thread. Here both the threads are ready to release the lock but no body will release this situtation is called deadlock in java.

ex:
---

class Test 
{
	public static void main(String[] args)throws InterruptedException 
	{
		final String res1="hi";
		final String res2="bye";
		
		Thread t1 = new Thread()
		{
			public void run()
			{
				synchronized(res1)
				{
					System.out.println("Thread1 : Locking Resource1");
					synchronized(res2)
					{
						System.out.println("Thread1 : Locking Resource2");
					}
				}
			}
		};
		
		Thread t2 = new Thread()
		{
			public void run()
			{
				synchronized(res2)
				{
					System.out.println("Thread2 : Locking Resource2");
					synchronized(res1)
					{
						System.out.println("Thread2 : Locking Resource1");
					}
				}
			}
		};
		
		t1.start();
		t2.start();
	}
}

Disadvantages of Multithreading 
==============================
1) Deadlock

2) Thread starvation 

3) Debugging 

























































































































