Method Overriding 
================
Having same method name with same parameters in two different classes is called method overriding.

Methods which are present in parent class are called overridden methods.

Methods which are present in child class are called overriding methods.

ex:
---
class Parent 
{
	//overridden methods 
	public void property()
	{
		System.out.println("House+Land+Gold");
	}
	public void marry()
	{
		System.out.println("Trisha");
	}
}
class Child extends Parent 
{
	//overriding methods 
	@Override
	public void marry()
	{
		System.out.println("Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p = new Parent();
		p.property(); // House+Land+Gold
		p.marry(); // Trisha 
		
		Child c = new Child();
		c.property(); // House+Land+Gold
		c.marry(); // Rashmika 
		
		Parent p1 = new Child();
		p1.property(); // House+Land+Gold
		p1.marry(); // Rashmika 
		
	}
}

If we declare any method as final then overriding of that method is not possible.

ex:
--
class Parent 
{
	public final void property()
	{
		System.out.println("House-Not For Sale");
	}
}
class Child extends Parent 
{
	@Override 
	public void property()
	{
		System.out.println("House-For Sale");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p = new Parent();
		p.property(); // House-Not For Sale 
	}
}

Child can use final methods but can't override.

ex:
--
class Parent 
{
	public final void property()
	{
		System.out.println("House-Not For Sale");
	}
}
class Child extends Parent 
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p = new Parent();
		p.property(); // House-Not For Sale 
		
		Child c = new Child();
		c.property(); // House-Not For Sale
	}
}

If parent don't want share the properties with child then we need to declare those properties as private.

ex:
---
class Parent 
{
	private void property()
	{
		System.out.println("House-Not For Sale");
	}
}
class Child extends Parent 
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p = new Parent();
		p.property(); // House-Not For Sale 
		
		Child c = new Child();
		c.property(); // C.T.E 
	}
}

Method Hiding 
=============
Method hiding exactly same as method overriding with following differences.

Method overriding 				Method hiding 
------------------				-------------
Methods should be non-static.			Methods should be static.

Method resolution will taken care by		Method resolution will taken care by 
JVM based on runtime object.			a compiler based on reference type.

It is also known as runtime polymorphism,	It is also known as compile time 
dynamic polymorphism or late binding.		polymorphism, static polymorphism or 
						early binding.

ex:
---
class Parent 
{
	public static void property()
	{
		System.out.println("House+Land+Gold");
	}
	public static void marry()
	{
		System.out.println("Trisha");
	}
}
class Child extends Parent 
{
	public static void marry()
	{
		System.out.println("Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p = new Parent();
		p.property(); // House+Land+Gold
		p.marry(); // Trisha 
		
		Child c = new Child();
		c.property(); // House+Land+Gold
		c.marry(); // Rashmika 
		
		Parent p1 = new Child();
		p1.property(); // House+Land+Gold
		p1.marry(); // Trisha 
		
	}
}


Q) Can we override main method in java?

No, We can't override main method in java because it is static.





Polymorphism 
============
Polymorphism has taken from Greek Word.

Here poly means many and morphism means forms. 

The ability to represent in a different forms is called polymorphism.

Diagram: class31.1

The main objective of polymorphism is to provide flexibility.

In java, polymorhism is divided into two types.

1) Compile time polymorphism 

2) Runtime polymorphism

1) Compile time polymorphism
----------------------------
A polymorphism which exhibits at compile time is called compile time polymorphism.

In compile time polymorphism method resolution will taken care by a compiler based on reference type.

It is also known as static polymorphism or early binding.
 
ex:
	Method overloading 
	Method hiding

2) Runtime polymorphism
-----------------------
A polymorphism which exhibits at runtime is called runtime polymorphism.

In runtime polymorphism method resolution will taken care by a JVM based on runtime object.

It is also knows dynamic polymorphism or late binding.

ex:
	Method overriding 

Diagram: class31.2


Constructor 
===========
It is a special method which is used to intialized an object.

Having same name as class name is called constructor.

It does not allow returntype. 

It will accept following modifiers.
ex:
	default 
	public 
	private 
	protected 

It is called when object is created.

In java , constructors are divided into two types.

1) Userdefined constructor 

2) Default constructor 

1) Userdefined constructor 
--------------------------
A constructor which is created by the user based on the application requirements is called user defined constructor.

It is classified into two types.

i) Zero-argument constructor 

ii) Parameterized constructor 


i) Zero-argument constructor 
-----------------------------
Suppose if we are not passsing any argument to userdefined constructor then that constructor is called zero argument constructor.

ex:
---

class Test 
{
	Test()
	{
		System.out.println("Constructor");
	}
	
	public static void main(String[] args)
	{
		System.out.println("Main-Method");
	}
}
o/p:
	Main-Method 

ex:
----

class Test 
{
	public Test()
	{
		System.out.println("Constructor");
	}
	
	public static void main(String[] args)
	{
		System.out.println("Main-Method");
		Test t = new Test();
	}
}
o/p:
	Main-Method 
	Constructor 

ex:
----

class Test 
{
	private Test()
	{
		System.out.println("Constructor");
	}
	
	public static void main(String[] args)
	{
		Test t1=new Test();
		System.out.println("Main-Method");
		Test t2 = new Test();
	}
}
o/p:
	Constructor 
	Main-Method
	Constructor 

ex:
----

class Test 
{
	protected Test()
	{
		System.out.println("Constructor");
	}
	
	public static void main(String[] args)
	{
		Test t1=new Test();
		System.out.println("Main-Method");
		Test t2 = new Test();
	}
}
o/p:
	Constructor 
	Main-Method
	Constructo

ii) Parameterized constructor 
-----------------------------
Suppose if we are passing atleast one argument to userdefined constructor then that constructor is called parameterized constructor.

ex:
---
class Employee 
{
	//current variables 
	private int empId;
	private String empName;
	private double empSal;
	
	public Employee(int empId,String empName,double empSal)
	{
		this.empId = empId;
		this.empName = empName;
		this.empSal = empSal;
	}
	public void getEmployeeDetails()
	{
		System.out.println("Employee Id :"+empId);
		System.out.println("Employee Name :"+empName);
		System.out.println("Employee Salary :"+empSal);
	}
}
class Test 
{
	public static void main(String[] args)
	{
			Employee e = new Employee(101,"Alan",1000d);
			e.getEmployeeDetails();
	}
}


2) Default constructor 
----------------------
It is a compiler generated constructor for every java program where we are not defining atleast zero argument constructor.

To see the default constructor we need to use below command.
ex:
	javap -c  Class-Name 

Diagram: class31.3

 
Q) What is constructor overloading?

Having same constructor name with different parameters in a single class is called constructor overloading.

ex:
---
class A 
{
	A()
	{
		System.out.println("0-arg const");
	}
	A(int i)
	{
		System.out.println("int-arg const");
	}
	A(double d)
	{
		System.out.println("double-arg const");
	}
}

class Test 
{
	public static void main(String[] args)
	{
		A a1 = new A();
		A a2 = new A(10);
		A a3 = new A(10.5d);
	}
}





























































































 


























































