case3: If we won't override run() method 
----------------------------------------
If we won't override run() method then Thread class run() method will execute automatically.

Thread class run() method is empty implementation. Hence we won't get any output from child thread.

ex:
--
class MyThread extends Thread
{
	
}
class Test  
{
	public static void main(String[] args) 
	{
		//instantiate a thread 
		MyThread t = new MyThread();
		
		//start new thread 
		t.start();
	
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

case4: If we overload run() method 
-----------------------------------
If we overload run() method then t.start() method always execute run() method with zero parameters only.

ex:
---
class MyThread extends Thread
{
	public void run()
	{
		System.out.println("0-arg method");
	}
	public void run(int i)
	{
		System.out.println("int-arg method");
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		//instantiate a thread 
		MyThread t = new MyThread();
		
		//start new thread 
		t.start();
	
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

case5: Life cycle of a thread 
-----------------------------
Diagram: class48.1


1) Once if we create a thread then our thread will be in new/born state.

2) Once if we invoke t.start() method then our thread will be in ready or runnable state.

3) If Thread Schedular allocates to CPU then out thread goes to running state.

4) Once run() method execution is completed then out thread enters to dead state.


2) By implementing Runnable interface 
=====================================
class MyRunnable implements Runnable 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
			MyRunnable r = new MyRunnable();
			
			Thread t = new Thread(r); // r is a targatable interface 
			
			//new thread 
			t.start();
			
			for(int i=1;i<=5;i++)
			{
				System.out.println("Parent-Thread");
			}
	}
}


Setting and Getting name of a thread 
====================================
In java, every thread has a name automatically generated by the JVM or explicitly created by the programmer.

We have following methods to set and get name of a thread.
ex:
	public final void setName(String name)
	public final String getName() 
	
ex:
---
class MyThread extends Thread 
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName()); // main 
		
		MyThread t = new MyThread();
		System.out.println(t.getName());// Thread-0
		
		Thread.currentThread().setName("Parent-Thread");
		System.out.println(Thread.currentThread().getName()); // Parent-Thread
		
		t.setName("Child-Thread");
		System.out.println(t.getName());//Child-Thread
		
	}
}



Daemon Thread 
=============
Daemon threads are low priority threads which are running in a background.

We have following list of daemon threads.

ex:
	Garbage Collector 
	Finalizer 
	Signal Dispatch 
	ActionListener 
	and etc. 

Daemon threads provides the services to user threads.

Life of daemon thread is depend upon user threads because when user thread died then daemon thread will die automatically.

We can change the behaviour of daemon thread before user threads. If we try to change the behaviour of daemon thread after user threads then we will get runtime exception called IllegalThreadStateException.

To change the behaviour of daemon thread we will use setDaemon(true) method.

To check a thread is a daemon or not we will use isDaemon() method.

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(Thread.currentThread().isDaemon());
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t = new MyThread();
		t.setDaemon(true);
		t.start();	
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}



Thread Priority 
===============
In java, every thread has a priority automatically generated by JVM or explicitly provided by the programmer.

The valid range of thread priority is 1 to 10. Where 1 is a least priority and 10 is a highest priority. 

If we take thread priority more then 10 then we will get runtime exception called IllegalArgumentException.

Thread class defines following standard constants as thread priority.
ex:
	Thread.MAX_PRIORITY  - 10
	Thread.NORM_PRIORITY - 5 
	Thread.MIN_PRIORITY  - 1 

We don't have such priority like LOW_PRIORITY and HIGH_PRIORITY.

A thread which is having highest priority will be executed first.

If multiple threads having same priority then we can't expect any execution order or exact output.

Thread schedular uses thread priority while allocating to CPU.

We have following methods to set and get thread priority.
ex:
	public final void setPriority(int priority)
	public final int getPriority() 

ex:
---
class MyThread extends Thread 
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getPriority()); // 5
		
		MyThread t = new MyThread();
		System.out.println(t.getPriority()); // 5 
		
		Thread.currentThread().setPriority(9);
		System.out.println(Thread.currentThread().getPriority()); // 9
		
		t.setPriority(4);
		System.out.println(t.getPriority()); // 4
		
		t.setPriority(11); // R.E IllegalArgumentException 
	}
}


Ways to prevent a thread from execution 
=======================================
There are three ways to prevent(stop) a thread from execution.

1) yield()

2) join() 

3) sleep() 

1) yield()
----------
It pause current execution thread and gives the priority to other threads having same priority.

If there is no waiting threads or low priority threads then same thread continue it's execution.

If multiple waiting threads same priority then we can't expect any execution order.

A thread which is yielded when it will get a chance for execution is dependent upon mercy of thread schedular.

ex:
	public static native void yield() 

Diagram: class48.2



























































