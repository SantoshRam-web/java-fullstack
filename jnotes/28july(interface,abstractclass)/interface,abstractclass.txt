Interfaces 
==========
Interface is a blue print of a class and it is a collection of abstract methods, default methods and static methods.

Abstract methods are incomplete methods because they end with semicolon and do not have any body.
ex:
	public abstract void methodOne();

It is not possible to create object for interfaces.

To write the implementation for abstract methods we will use implementation class.

It is possible to create object for implementation class because it contains method with body.

By default every abstract method is public and abstract.
ex:
	void methodOne();

Interface contains only constants i.e public static final.

If we know service requirement specification then we need to use interface.

Diagram: class32.1

To declare interface we will use interface keyword.

syntax:
-------
	interface  <interface_name>
	{
		-
		- // abstract methods 
		- // static methods 	
		- // default methods 
		- // constants 
		-	
	}

ex:
---
interface A 
{
	//abstract method 
	public abstract void methodOne();
}
class B implements A 
{
	@Override
	public void methodOne()
	{
		System.out.println("MethodOne");
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		A a = new B();
		a.methodOne();
	}
}

ex:
---
interface A 
{
	//abstract method 
	public abstract void methodOne();
}
class Test  
{
	public static void main(String[] args) 
	{
		//Anonymous inner class
		A a = new A()
		{
			public void methodOne()
			{
				System.out.println("From MethodOne");
			}
		};
		a.methodOne();
	}
}

Note:
-----
If interface contains four methods then we need to override all methods otherwise we will get compile time error.


ex:
---
interface A 
{
	public abstract void show();
	public void display();
	abstract void see();
	void view();
}
class B implements A 
{
	@Override
	public void show()
	{
		System.out.println("show-method");
	}
	@Override
	public void display()
	{
		System.out.println("display-method");
	}
	@Override
	public void see()
	{
		System.out.println("see-method");
	}
	@Override
	public void view()
	{
		System.out.println("view-method");
	}
}
class Test  
{
	public static void main(String[] args) 
	{
			A a = new B();
			a.show();
			a.display();
			a.see();
			a.view();
	}
}

Note:
------
A class can't extends more then one class simultenously but interface can extends more then interface simultenously

ex:
---
interface A 
{
	void m1();
}
interface B 
{
	void m2();
}
interface C extends A,B
{
	void m3();
}
class D implements C 
{
	@Override 
	public void m1()
	{
		System.out.println("M1-Method");
	}
	@Override 
	public void m2()
	{
		System.out.println("M2-Method");
	}
	@Override 
	public void m3()
	{
		System.out.println("M3-Method");
	}
}
class Test 
{
	public static void main(String[] args)
	{
			C c = new D();
			c.m1();
			c.m2();
			c.m3();
	}
}

Note:
-----
A class can implements more then one interface.

ex:
---
interface Father 
{
	//constant 
	float HT = 6.2f;
	
	//abstract method 
	void height();
}
interface Mother 
{
	//constant  
	float HT = 5.8f;
	
	//abstract method 
	void height();
}
class Child implements Father,Mother 
{
	@Override 
	public void height()
	{
		float height = (Father.HT+Mother.HT)/2;
		System.out.println("Child Height :"+height);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Child c = new Child();
		c.height();
	}
}


Marker interface 
================
Interface which does not contain any methods or constants is called marker interface.

In general, empty interface is called marker interface.

Using marker interfaces we will get some ability to do.

We have following list of marker interfaces in java.
ex:
	Serializable 
	Cloneable 
	Remote 
	and etc.



Abstract class
===============
Abstract class is a collection of zero or more abstract methods and concrete methods.

A abstract keyword is applicable for methods and classes but not for variables.

It is not possible to create object for abstract class.

To write the implementation of abstract methods we will use sub classes.

By default every abstract method is public and abstract.

Abstract class contains only instance variables.

If we know partial implementation then we need to use abstract class.

To declare abstract class we will use abstract keyword.

syntax:
------
	abstract class <class_name>
	{
		-
		- // abstract method 
		- // concrete methods 
		- // instance variables 
		-
	}

ex:
---
abstract class Animal 
{
	//abstract method 
	public abstract void sound();
}
class Dog extends Animal 
{
	@Override 
	public void sound()
	{
		System.out.println("Bow Bow");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Dog d =new Dog();
		d.sound();
	}
}



ex:
---
abstract class Animal 
{
	//abstract method 
	public abstract void sound();
	
	//concrete method 
	public void sleep()
	{
		System.out.println("Night Time");
	}
}
class Dog extends Animal 
{
	@Override 
	public void sound()
	{
		System.out.println("Bow Bow");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Dog d =new Dog();
		d.sound();
		d.sleep();
	}
}


ex:
---
abstract class Plan 
{
	//instance variable 
	protected double rate;
	
	//abstract method 
	public abstract void getRate();
	
	//concrete method 
	public void calculateBill(int units)
	{
		System.out.println("Total Units :"+units);
		System.out.println("Total Bill : "+(rate*units));
	}
}
class DomesticPlan extends Plan 
{
	@Override
	public void getRate()
	{
		rate = 2.5d;
	}
}
class CommercialPlan extends Plan
{
	@Override
	public void getRate()
	{
		rate = 5.0d;
	}
}
class Test 
{
	public static void main(String[] args)
	{
		DomesticPlan dp = new DomesticPlan();
		dp.getRate();
		dp.calculateBill(100);
		
		CommercialPlan cp = new CommercialPlan();
		cp.getRate();
		cp.calculateBill(100);
	}
}







































































